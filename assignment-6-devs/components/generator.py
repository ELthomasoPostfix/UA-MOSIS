import uuid
import numpy as np

from dataclasses import dataclass, field, InitVar

from pypdevs.DEVS import AtomicDEVS
from pypdevs.infinity import INFINITY

from components.messages import Car, QueryAck, Query

from other.constants import DV_POS_MAX, DV_NEG_MAX, V_PREF_FALLBACK



@dataclass
class GeneratorState:
    n: int = 0
    """The total number of Cars generated by the Generator until now."""
    simulated_time: float = 0.0
    """Pattern 2: simulated time. It represents a timer that started when the simulation began. Note that this value is updated in extTransition() and intTransition(), so the simulated time is accurate up until the moment where the last internal or external event was received."""
    next_car: Car | None = None
    """The next Car event to output from the Generator's output port."""
    next_car_IAT: float = 0.0
    """The IAT -- the delay since the previous Car event; when to generate the next Car event."""
    next_car_Ack: QueryAck | None = None
    """The QueryAck that signifies that the next car may be sent to the car_out port."""
    query_delay_time: float = 0.0
    """Should ONLY take on the values 0.0 and INFINITY. A delay variable used both to immediately send a Query on Q_send and to wait until the corresponding QueryAck is received from Q_ack."""
    rng_seed: InitVar[int | None] = None
    """The seed for the RNG. Defaults to seed None, which represents a randomized seed that is chosen at runtime. So the default seed does not guarantee that two sequential simulations will sample the same random values using the RNG."""
    rng: np.random.Generator = field(init=False)
    """The RNG used for sampling the Car v_pref values from a normal dist. AND IAT values from a uniform dist. AND the Car no_gas booleans from a bernoulli experiment (binomial dist.)."""

    def __post_init__(self, rng_seed: InitVar[int | None]):
        self.rng = np.random.default_rng(rng_seed)


class Generator(AtomicDEVS):
    """Periodically generates Cars. This component allows cars to enter the system.
    The inter-arrival time (IAT) for the Cars is given by a uniform distribution.
    Upon generation, each car is given a preferred velocity v_pref by sampling from a normal distribution.

    When a Car is generated, a Query is sent over the Q_send port. As soon as a QueryAck is received,
    the generated car is output over the car_out port. Next, the Generator waits for some time before
    generating another Car. Upon generation, the Car's no_gas is randomly set to be either true or false.
    """

    def __init__(self, block_name: str, IAT_min: float, IAT_max: float,
                 v_pref_mu: float, v_pref_sigma: float, destinations: list, limit: int,
                 rng_seed: int | None = None):
        """
        :param block_name: The name for this model. Must be unique inside a Coupled DEVS.
        :param IAT_min: Lower bound for the IAT uniform distribution.
        :param IAT_max: Upper bound for the IAT uniform distribution.
        :param v_pref_mu: Mean of the normal distribution that is used to sample v_pref.
        :param v_pref_sigma: Standard deviation of the normal distribution that is used to sample v_pref.
        :param destinations: A non-empty list of potential (string) destinations for the Cars. A random destination will be selected.
        :param limit: Upper limit of the number of Cars to generate.
        :param rng_seed: The initial seed to pass to the RNG used for sampling Car properties.
        """
        super(Generator, self).__init__(block_name)

        assert len(destinations) > 0, f"The destinations list of a {self.__class__.__name__} MUST be non-empty"

        self.state: GeneratorState = GeneratorState(rng_seed=rng_seed)

        # Immutable members -- should NOT be part of the model state member
        self.IAT_min: float = IAT_min
        self.IAT_max: float = IAT_max
        self.v_pref_mu: float = v_pref_mu
        self.v_pref_sigma: float = v_pref_sigma
        self.destinations: list = destinations
        self.limit: int = limit
        self.DV_POS_MAX: float = DV_POS_MAX
        self.DV_NEG_MAX: float = DV_NEG_MAX
        self.V_PREF_FALLBACK: float = V_PREF_FALLBACK

        # Ports
        self.Q_rack = self.addInPort("Q_rack")
        """Port that receives QueryAck events. When such an event is received, the next Car will be outputted after the QueryAck's t_until_dep time has passed. This way, there will not be any crashes due to a Generator."""
        self.car_out = self.addOutPort("car_out")
        """Outputs the newly generated Car. The current simulation time becomes the Car's departure_time."""
        self.Q_send = self.addOutPort("Q_send")
        """Sends a Query as soon as the newly sampled IAT says so."""

    def timeAdvance(self):
        """May NOT edit state."""

        # Simply idle when limit Cars have been generated.
        # This will prevent intTransitions() from occurring,
        # so no extraneous Car could ever be generated.
        if self.state.n >= self.limit:
            return INFINITY

        car_is_generated: bool = self._car_is_generated()
        ack_is_received: bool = self._ack_is_received()

        # No Car? Schedule next car generation (wait IAT)
        if not car_is_generated:
            return self.state.next_car_IAT

        # Immediately after Car generation, send out Query
        # OR Idle until QueryAck is received
        elif car_is_generated and not ack_is_received:
            return self.state.query_delay_time  # Is 0.0 OR INFINITY

        elif car_is_generated and ack_is_received:
            return self.state.next_car_Ack.t_until_dep

        # ELSE fallthrough; should NEVER be reached!
        # ==> Idle is a safe fallthrough for a generator
        return INFINITY

    def extTransition(self, inputs):
        """May edit state."""
        # Update simulation time
        self.state.simulated_time += self.elapsed
        # Schedule new Car entering the simulation / leaving the generator
        if self.Q_rack in inputs:
            query_ack: QueryAck = inputs[self.Q_rack]

            # Ignore ALL QueryAcks that are not meant for this AtomicDEVS component.
            if self.state.next_car is None or self.state.next_car.ID != query_ack.ID:
                return self.state

            self.state.next_car_Ack = query_ack
            # Set Car departure time, because outputFnc() may not do it and
            # intTransition() executes AFTER outputFnc()
            self.state.next_car.departure_time = self.state.simulated_time + query_ack.t_until_dep
        return self.state

    def outputFnc(self):
        """May NOT edit state."""
        car_is_generated: bool = self._car_is_generated()
        ack_is_received: bool = self._ack_is_received()

        if car_is_generated and not ack_is_received:
            return {
                self.Q_send: Query(self.state.next_car.ID)
            }
        elif car_is_generated and ack_is_received:
            return {
                self.car_out: self.state.next_car
            }

        return {}

    def intTransition(self):
        """May edit state."""
        # Update simulation time
        self.state.simulated_time += self.timeAdvance()

        car_is_generated: bool = self._car_is_generated()
        ack_is_received: bool = self._ack_is_received()

        # Generate Car, IAT expired
        if not car_is_generated:
            v_pref: float = self.state.rng.normal(self.v_pref_mu, self.v_pref_sigma)
            if v_pref <= 0.0:
                v_pref = self.V_PREF_FALLBACK
            no_gas: bool = self.state.rng.binomial(1, 0.5)
            destination: str = self.state.rng.choice(self.destinations)
            nxt_car: Car = Car(uuid.uuid4(), v_pref, self.DV_POS_MAX, self.DV_NEG_MAX,
                               no_gas=no_gas, destination=destination)
            self.state.next_car = nxt_car
        # Set timeAdvance() as to be idle until QueryAck received
        elif car_is_generated and not ack_is_received:
            self.state.query_delay_time = INFINITY
        # Car was output, schedule next car generation
        elif car_is_generated and ack_is_received:
            # Cleanup
            self.state.next_car = None
            self.state.next_car_Ack = None
            self.state.query_delay_time = 0.0  # Reset the QueryAck receival delay
            # Sample IAT
            self.state.next_car_IAT = self.state.rng.uniform(self.IAT_min, self.IAT_max)
            # Incrementing the count immediately after Car is output, prevents the IAT
            # from ever expiring and generating another Car
            self.state.n += 1

        return self.state

    def _car_is_generated(self) -> bool:
        """Check whether a Car has already been generated."""
        return self.state.next_car is not None

    def _ack_is_received(self) -> bool:
        """Check whether a QueryAck has already been received in response to a Query."""
        return self.state.next_car_Ack is not None
